#!/usr/bin/env python3

import os
import sys
import atexit
import typing
import re
from string import Template

TERM_RESET = "\033[0m"
TERM_BOLD  = "\033[1m"
TERM_RED   = "\033[31m"

prog_name : str        = sys.argv[0]
prog_args : list[str]  = sys.argv[1:]
call_dir  : str        = os.path.abspath(os.getcwd())

license_str = """
/* 
 * MIT License
 * 
 * Copyright (c) 2023-2024 Axel PASCON
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
"""

types_list = [
    ["char", "wchar"],
    ["char", "char8"],
    ["char", "char16"],
    ["char", "char32"],
    ["char", "utf8"],
    ["char", "utf16"],
    ["char", "utf32"],

    ["wchar", "char8"],
    ["wchar", "char16"],
    ["wchar", "char32"],
    ["wchar", "utf8"],
    ["wchar", "utf16"],
    ["wchar", "utf32"],

    ["char8", "char16"],
    ["char8", "char32"],
    ["char8", "utf8"],
    ["char8", "utf16"],
    ["char8", "utf32"],

    ["char16", "char32"],
    ["char16", "utf8"],
    ["char16", "utf16"],
    ["char16", "utf32"],

    ["char32", "utf8"],
    ["char32", "utf16"],
    ["char32", "utf32"],

    ["utf8", "utf16"],
    ["utf8", "utf32"],

    ["utf16", "utf32"]
]

struct_template = Template("""

#undef  CURRENT_CONVERTER_TYPE
#define CURRENT_CONVERTER_TYPE /* Define the converter type here if used, void otherwise */

#undef  UNISTREAMS_CURRENT_STRCONV_SPECIALIZATION
#undef  UNISTREAMS_CURRENT_STRCONV_SPECIALIZATION_STRING
#define UNISTREAMS_CURRENT_STRCONV_SPECIALIZATION uni::detail::string_conversions<${type1}, ${type2}>
#define UNISTREAMS_CURRENT_STRCONV_SPECIALIZATION_STRING PP_STRINGIZE(::UNISTREAMS_CURRENT_STRCONV_SPECIALIZATION)

template <>
struct ::UNISTREAMS_CURRENT_STRCONV_SPECIALIZATION
    : protected ::uni::detail::str_conv_base
{
    private:
        typedef ${type1} char_from;
        typedef ${type2} char_to;

        typedef CURRENT_CONVERTER_TYPE converter_type;

        /* Add needed typedefs here */

    public:
};
                           
#undef  UNISTREAMS_CURRENT_STRCONV_SPECIALIZATION
#undef  UNISTREAMS_CURRENT_STRCONV_SPECIALIZATION_STRING
#define UNISTREAMS_CURRENT_STRCONV_SPECIALIZATION uni::detail::string_conversions<${type2}, ${type1}>
#define UNISTREAMS_CURRENT_STRCONV_SPECIALIZATION_STRING PP_STRINGIZE(::UNISTREAMS_CURRENT_STRCONV_SPECIALIZATION)

template <>
struct ::UNISTREAMS_CURRENT_STRCONV_SPECIALIZATION
    : protected ::uni::detail::str_conv_base
{
    private:
        typedef ${type2} char_from;
        typedef ${type1} char_to;

        typedef CURRENT_CONVERTER_TYPE converter_type;

        /* Add needed typedefs here */

    public:
};

#undef  CURRENT_CONVERTER_TYPE
#undef  UNISTREAMS_CURRENT_STRCONV_SPECIALIZATION
#undef  UNISTREAMS_CURRENT_STRCONV_SPECIALIZATION_STRING

""")

def parse_cmdline_type_pairs(args: list[str]) -> list[tuple[str, str]]:
    def print_groups(groups: re.Match):
        for i in range(1, len(groups.groups()) + 1):
            print(f"Group {i}: {groups.group(i)}")
    if len(args) == 0:
        unreachable()
    type_regex = r"(char|wchar|char8|char16|char32|utf8|utf16|utf32)"
    tuple_regex = re.compile(r"^\s*" + type_regex + r"\s*,\s*" + type_regex + r"\s*$")
    type_list = []
    for arg in args:
        match = tuple_regex.match(arg)
        if match is None:
            print_error(f"Invalid type pair: {arg}")
            return []
        print_groups(match)
        type_list.append((match.group(1), match.group(2)))
    return type_list

def anyof(args: list[typing.Any], func: typing.Callable[[typing.Any], bool]) -> bool:
    for arg in args:
        if func(arg):
            return True
    return False

@typing.no_type_check
def unreachable() -> typing.NoReturn:
    print_error("Unreachable code reached")
    typing.assert_never()

def goto_exe_dir():
    os.chdir(os.path.dirname(os.path.realpath(__file__)))
    return

def goto_base_dir():
    os.chdir(call_dir)
    return

def check_argc(*args) -> bool:
    if len(args) == 0:
        return len(prog_args) >= 1
    elif len(args) == 1:
        if args[0] == "classic" or args[0] == "noremove":
            return len(prog_args) == 1
        elif args[0] == "allof":
            return len(prog_args) >= 2
        elif args[0] == "help":
            return True
        else:
            return False
    unreachable()

def generate_content(t1: str, t2: str) -> str:
    def generate_type(t: str) -> str:
        if t == "char":
            return "char"
        elif t == "wchar":
            return "wchar_t"
        elif t == "char8":
            return "char8_t"
        elif t == "char16":
            return "char16_t"
        elif t == "char32":
            return "char32_t"
        elif t == "utf8":
            return "utf8_char"
        elif t == "utf16":
            return "utf16_char"
        elif t == "utf32":
            return "utf32_char"
        else:
            raise ValueError(f"Invalid type {t}")
    return license_str + struct_template.substitute(type1=generate_type(t1), type2=generate_type(t2))

def generate_file_name(t1: str, t2: str) -> str:
    return f"{t1}_{t2}.ipp"    

def generate_classic():
    for types in types_list:
        file = os.path.abspath(generate_file_name(types[0], types[1]))
        if os.path.exists(file):
            os.remove(file)
        with open(file, "w") as f:
            print(f"Creating file {file}")
            f.write(generate_content(types[0], types[1]))
    return

def generate_noremove():
    for types in types_list:
        file = os.path.abspath(generate_file_name(types[0], types[1]))
        if os.path.exists(file):
            print(f"File {file} already exists, skipping")
            continue
        with open(file, "w") as f:
            print(f"Creating file {file}")
            f.write(generate_content(types[0], types[1]))
    return

def generate_allof(genlist: list[tuple[str, str]]):
    assert False, "Not implemented"
    return

def print_error(msg: str):
    print(f"{TERM_RED}{TERM_BOLD}ERROR: {TERM_RESET}{msg}")
    return

def usage():
    print(f"Usage: {prog_name} [help|classic|noremove|allof (type, type) [(type, type) ...]]")
    print("\thelp: Display this message")
    print("\tclassic: Generate all files and remove existing ones")
    print("\tnoremove: Generate all files and skip existing ones")
    print("\tallof: Generate all files for all specified type pairs")
    return

def main() -> int:
    atexit.register(goto_base_dir)
    goto_exe_dir()
    if not check_argc():
        print_error("Invalid number of arguments: expected at least one argument")
        usage()
        return 1
    if anyof(prog_args, lambda x: str(x).strip() == "help"):
        usage()
        return 1
    if prog_args[0] == "classic":
        if not check_argc("classic"):
            print_error("Invalid number of arguments: expected exactly one argument")
            usage()
            return 1
        generate_classic()
        return 0
    if prog_args[0] == "noremove":
        if not check_argc("noremove"):
            print_error("Invalid number of arguments: expected exactly one argument")
            usage()
            return 1
        generate_noremove()
        return 0
    if prog_args[0] == "allof":
        if not check_argc("allof"):
            print_error("Invalid number of arguments: expected at least two arguments")
            usage()
            return 1
        genlist = []
        generate_allof(genlist)
        return 0
    else:
        print_error(f"Invalid argument \"{prog_args[0]}\"")
        usage()
        return 1

""" if __name__ == "__main__":
    exit(main()) """

import pprint

#pprint.pprint(types_list)

pprint.pprint(
    parse_cmdline_type_pairs(prog_args)
)